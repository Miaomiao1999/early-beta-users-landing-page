function L = LenFun(breaks, coefsx, coefsy)
%
%         L = LenFun(breaks, coefsx, coefsy);
%
%  This function calculates the arc length of a curve by extracting the cubic
%  polynomial form of the spline on each subinterval using the Matlab function
%  unmkpp then integrating the resulting polynomials directly.
%
%  Input: breaks, coefsx, coefsy  - vectors containing the tabular data
%  Output:  L - approximation of the integral
%
L = 0;
for i = 1: length(breaks)-1
    f = @(t) sqrt((3.*coefsx(i,1).*(t-breaks(i)).^2 + ...
               2.*coefsx(i,2).*(t-breaks(i)) + coefsx(i,3)).^2 + ...
              (3.*coefsy(i,1).*(t-breaks(i)).^2 + ...
              2.*coefsy(i,2).*(t-breaks(i)) + coefsy(i,3)).^2);
L = L + integral(f, breaks(i), breaks(i+1));
end
function [xvals, yvals, L] = ParSpline2(x, y)
t= zeros(1,length(x));
  t(1) = 0;
for i = 2:length(x)
   t(i) = t(i-1) + sqrt((x(i)-x(i-1))^2 + (y(i)-y(i-1))^2);
end
% xx is a set of 500 values to be evaluated
xx = linspace(0, t(length(x)) ,500);


 % construct the spline with t and x
Sx = spline(t, x);
% construct the spline with t and y
Sy = spline(t, y);
% output xvals and yvals are vectors containing
% 500 values of Sx(t) and Sy(t)
xvals= ppval(Sx, xx);
yvals= ppval(Sy, xx);
 [breaks, coefsx] = unmkpp(Sx);
 % breaks is a vector containing the given ti data points
 % coefs is a matrix containing the coefficients of each of
 % the polynomial pieces.
 % since breaks for Sx and Sy are the same, we will just use breaks here
 % also for Sy
 [breaks, coefsy] = unmkpp(Sy);
 L = LenFun(breaks, coefsx, coefsy)
 figure(1),clf
% Figure must have focus before ginput can receive input,
% so I set x-axis and y-axis to be from 0 to 1.
axis([0,1,0,1]),
grid on,  % add grids
hold on % retain current plot when adding new plots to the axes
% n is the number of points needed to construct a curve.
n = input(’How many points do you want to collect?’);
% Use the mouse and click on the points I want to collect.
x = zeros(n,1);
y = zeros(n,1);
% Create a for loop to repeat the process of locating those points and
% plot them as circles.
for i = 1:n
   [x(i),y(i)] = ginput(1);
   plot(x(i), y(i), ’r-o’)
end


% After I have selected all of the points, cubic splines are used to
% generate the curves through the points.
% Here we use ParSpline2.m to get xvals and yvals.
[xvals, yvals, L] = ParSpline2(x, y);
% plot the curve generated by ParSpline2
F = plot(xvals, yvals, ’b’);
legend(F, ’ParSpline2 curve’)
title(sprintf(’Length of curve = %1.4d’,L),’FontSize’, 20)
hold off
grid off
